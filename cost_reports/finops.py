#!/usr/bin/env python3

# script breaks down an AWS Organization bill by CostCenter
# If a line item has a CostCenter (or CostCenterOther if appropriate)
# tag, it's value will be used; otherwise the CostCenter tag
# for the associated account will be used.

import logging
import re

import boto3
import pandas as pd


LOG = logging.getLogger(__name__)
LOG.setLevel(logging.INFO)

BILL_START_DATE_COLUMN = 'bill_billing_period_start_date'
LINE_ITEM_ID_COLUMN = 'identity_line_item_id'
ACCOUNT_ID_COLUMN = 'line_item_usage_account_id'
VALUE_COLUMN = 'line_item_unblended_cost'
COST_CENTER_COLUMN = 'resource_tags_user_cost_center'
COST_CENTER_OTHER_COLUMN = 'resource_tags_user_cost_center_other'
CLOUDFORMATION_STACK_COLUMN = 'resource_tags_aws_cloudformation_stack_name'
SERVICE_CATALOG_PRINCIPAL_COLUMN = 'resource_tags_aws_servicecatalog_provisioning_principal_arn'
LINE_ITEM_TYPE_COLUMN = 'line_item_line_item_type'
PRODUCT_NAME_COLUMN = 'product_product_name'
USAGE_TYPE_COLUMN = 'line_item_usage_type'
DESCRIPTION_COLUMN = 'line_item_line_item_description'

ACCOUNT_COST_CENTER_COLUMN = 'account_cost_center'
ACCOUNT_NAME_COLUMN = 'account_name'

CALC_COST_CENTER_COLUMN = 'calculated_cost_center'

TAG_REPLACEMENT = {
    'Indirects':'NO PROGRAM / 000000',
    'No Program / 000000':'NO PROGRAM / 000000'
}


def main(cur_parquet, account_dict):
    """
    Parameters
    ----------
    cur_parquet: pandas.DataFrame
        The Cost and Usage Report generated by AWS Billing.

    account_dict: dict
        A mapping of account IDs to their CostCenter tag.


    Returns
    -------
    numpy.datetime64:
        Date to select rows for the month being processed.

    pandas.DataFrame:
        DataFrame with added `calculated_cost_center` column.

    float:
        Total cost of all line items in the DataFrame.
    """

    # Create a datafrom from the account dict
    LOG.info("Reading account data")
    accounts = pd.DataFrame.from_dict(account_dict)

    # Read in the month's cost and usage report
    columns=[
        LINE_ITEM_ID_COLUMN,
        VALUE_COLUMN,
        ACCOUNT_ID_COLUMN,
        COST_CENTER_COLUMN,
        COST_CENTER_OTHER_COLUMN,
        CLOUDFORMATION_STACK_COLUMN,
        SERVICE_CATALOG_PRINCIPAL_COLUMN,
        LINE_ITEM_TYPE_COLUMN,
        PRODUCT_NAME_COLUMN,
        USAGE_TYPE_COLUMN,
        DESCRIPTION_COLUMN,
        BILL_START_DATE_COLUMN
    ]

    LOG.info("Reading billing parquet file")
    raw_cur_data = pd.read_parquet(cur_parquet, columns=columns)

    # Compute total cost for the month
    LOG.info("Calculating original total")
    total_cost = raw_cur_data[VALUE_COLUMN].sum()

    # Ignore rows with no value
    acct_rows = raw_cur_data.loc[raw_cur_data[VALUE_COLUMN] != 0.0]

    # check for a single bill
    bill_dates = acct_rows[BILL_START_DATE_COLUMN].unique()
    if len(bill_dates) > 1:
        raise Exception(f'Multiple billing periods detected: {bill_dates}')
    else:
        report_date = bill_dates[0]

    # we now want to inner join df with accounts on ACCOUNT_ID_COLUMN <-> 'account_id'
    LOG.info("Joining data sources on account id")
    accounts = accounts.rename(columns={'account_id': ACCOUNT_ID_COLUMN})
    joined = acct_rows.join(accounts.set_index(ACCOUNT_ID_COLUMN), on=ACCOUNT_ID_COLUMN, how="left")

    # use AWS' line item id as the index
    LOG.info("Setting line item ID as index")
    joined.set_index(LINE_ITEM_ID_COLUMN, inplace=True)

    # Add a column for the calculated cost center
    LOG.info("Adding calculated cost centers from tags")
    joined[CALC_COST_CENTER_COLUMN] = joined.apply(lambda row: cost_center_lookup(row), axis=1)

    # Check that everything still adds up
    LOG.info("Verifying total")
    total = joined[VALUE_COLUMN].sum()
    if (abs(total-total_cost)>0.01):
        LOG.error(f"Original total: {total_cost}, munged total: {total}")
        raise Exception("categorized costs do not add up to total bill.")

    return report_date, joined, total

def valid_value(check_value):
    if check_value is None:
        return False
    if check_value == 'na':
        return False
    if str(check_value) == 'nan':
        return False

    return True

def cost_center_lookup(row):
    cost_center = None

    if valid_value(row[COST_CENTER_COLUMN]):
        cost_center = row[COST_CENTER_COLUMN]

    if cost_center == 'Other / 000001':
        if valid_value(row[COST_CENTER_OTHER_COLUMN]):
            cost_center = row[COST_CENTER_OTHER_COLUMN]

    if cost_center is None:
        cost_center = row[ACCOUNT_COST_CENTER_COLUMN]

    # replace invalid values
    if not valid_value(cost_center):
        cost_center = 'Unknown / 999999'

    # replace tags that look like "name_123456" with "name / 123456"
    cost_center = re.sub(r'(_)([0-9]{5,6})', (lambda x: " / " + x.group(2)), str(cost_center))

    # normalize 000000 case
    if cost_center in TAG_REPLACEMENT:
        cost_center = TAG_REPLACEMENT[cost_center]

    return cost_center
